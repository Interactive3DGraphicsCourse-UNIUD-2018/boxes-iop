<!DOCTYPE html>
<html>
    <head>
        <title>Space Shuttle tests struttura</title>

        <style>
            body {
                font-family: Monospace;
                background-color: #f0f0f0;
                margin: 0px;
                overflow: hidden;
            }

            canvas {
                width: 100%;
                height: 100%;
            }

        </style>

        <script src="lib/three.min.js"></script>
        <script src="lib/stats.min.js"></script>
        <script src="lib/Coordinates.js"></script>
        <script src="lib/OrbitControls.js"></script>
    </head>
    <body>
        <script>
            /*  DEFINIZIONE DI TUTTE LE VARIABILI   */

            var scene, camera, renderer, controls, stats;

            //variabili per lo shuttle
            var shuttle, external_tank, razzo_dx, razzo_sx, propulsore1, propulsore2, propulsore3;
            var larghezza_shuttle, altezza_shuttle, spessore_shuttle;
            var durataAnimazione, time;
            var riposizionato;

            //variabili per la torre
            var larghezza_tower, altezza_tower, spessore_tower;
            var tower, tower_top_arm, tower_mid_arm_top, tower_mid_arm_base;
            var angolo, angolo_return;

            //variabili per la base di lancio
            var larghezza_base, altezza_base, spessore_base;
            var launch_base;

            //variabili per il fumo
            var smoke_column;

            //variabili per le fiamme
            var flames_propulsore1, flames_propulsore2, flames_propulsore3, flames_razzo_dx, flames_razzo_sx;
            var flames1, flames2, flames3, flames4, flames5;

            var environment;

            
            /* FUNZIONI */

            function Start() { //chiamo le funzioni di costruzione del paesaggio e dello space shuttle
                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 10000);

                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setClearColor(0x3333aa);
                document.body.appendChild(renderer.domElement);

                /*  DEFINIZIONE MISURE DI BASE  */

                //dimensioni del blocco centrale dello shuttle, su cui vengono proporzionate tutte le altre componenti
                larghezza_shuttle = 30;
                altezza_shuttle = 100;
                spessore_shuttle = 15;

                //dimensioni della torre
                larghezza_tower = 50;
                altezza_tower = 220;
                spessore_tower = 50;

                //dimensioni della base di lancio
                larghezza_base = 200;
                altezza_base = 50;
                spessore_base = 200;

                /*  CREAZIONE DEGLI OGGETTI */

                environment = new THREE.Object3D();

                //creazione e posizionamento del terreno
                Terreno();

                //creazione dello shuttle e dei pivot interni ad esso
                shuttle = new THREE.Object3D();
                propulsore1 = new THREE.Object3D();
                propulsore2 = new THREE.Object3D();
                propulsore3 = new THREE.Object3D();
                Shuttle();

                //creazione delle fiamme dei propulsori
                flames_propulsore1 = new THREE.Object3D();
                flames1 = new Array();
                Flames_creation(larghezza_shuttle/3, flames1);
                flames_propulsore2 = new THREE.Object3D();
                flames2 = new Array();
                Flames_creation(larghezza_shuttle/3, flames2);
                flames_propulsore3 = new THREE.Object3D();
                flames3 = new Array();
                Flames_creation(larghezza_shuttle/3, flames3);

                //creazione del serbatoio esterno
                external_tank = new THREE.Object3D();
                External_tank(); //costruisce il serbatoio centrale
                shuttle.add(external_tank);

                //creazione dei razzi destro e sinistro, pos serve a distinguerli al momento di posizionarli nella funzione Razzo()
                var pos = 0;
                razzo_dx = new THREE.Object3D();
                Razzo(razzo_dx, pos);
                shuttle.add(razzo_dx);

                //creazione delle fiamme del razzo dx
                flames_razzo_dx = new THREE.Object3D();
                flames4 = new Array();
                Flames_creation(larghezza_shuttle/2, flames4);


                pos = 1;
                razzo_sx = new THREE.Object3D();
                Razzo(razzo_sx, pos);
                shuttle.add(razzo_sx);

                //creazione delle fiamme del razzo sx
                flames_razzo_sx = new THREE.Object3D();
                flames5 = new Array();
                Flames_creation(larghezza_shuttle/2, flames5);

                //creazione della colonna di fumo
                smoke_column = new THREE.Object3D();
                Smoke_creation(larghezza_shuttle*3);

                //posizionamento dello shuttle nella scena
                shuttle.position.set(-(larghezza_tower/3), altezza_shuttle*1.4, 0);

                //creazione della torre
                tower = new THREE.Object3D();
                tower_mid_arm_base = new THREE.Object3D();
                tower_mid_arm_top = new THREE.Object3D();
                tower_top_arm = new THREE.Object3D();
                Tower();
                tower.add(tower_mid_arm_base);
                tower.add(tower_mid_arm_top);
                tower.add(tower_top_arm);

                //posizionamento della torre nella scena
                tower.position.set(-(larghezza_base/2 + larghezza_tower), altezza_tower/10, 0);

                //inizializzazione delle variabili necessarie per l'animazione della torre
                angolo = 0;
                angolo_return = 0;

                //creazione della base di lancio
                launch_base = new THREE.Object3D();
                Launch_base();

                //posizionamento della base di lancio nella scena
                launch_base.position.set(0, altezza_base/2, 0);

                //inizializzazione delle variabili necessarie per l'animazione dello shuttle
                durataAnimazione = 10000;
                riposizionato = false;

                //aggiunta degli oggetti al pivot esterno e successiva aggiunta di questo alla scena
                environment.add(shuttle);
                environment.add(tower);
                environment.add(launch_base);
                scene.add(environment);

                //riquadro fps
                stats = new Stats();
                stats.domElement.style.position = 'absolute';
                stats.domElement.style.top = '0px';
                document.body.appendChild(stats.domElement);

                //controlli orbitali
                controls = new THREE.OrbitControls(camera);
                controls.addEventListener('change', Render);
                
                //posizionamento e controllo della camera
                camera.position.set(100,200,250);
                controls.target = shuttle.position;
                controls.autoRotateSpeed = 4;
            }

            //return array with height data from img, taken from: http://danni-three.blogspot.it/2013/09/threejs-heightmaps.html
		    function getHeightData(img,scale) {
  
                if (scale == undefined) 
                    scale=1;

                var canvas = document.createElement( 'canvas' );
                canvas.width = img.width;
                canvas.height = img.height;
                var context = canvas.getContext( '2d' );

                var size = img.width * img.height;
                console.log(size);
                var data = new Float32Array( size );

                context.drawImage(img,0,0);

                for ( var i = 0; i < size; i ++ ) {
                    data[i] = 0
                }

                var imgd = context.getImageData(0, 0, img.width, img.height);
                var pix = imgd.data;

                var j=0;
                for (var i = 0; i<pix.length; i +=4) {
                    var all = pix[i]+pix[i+1]+pix[i+2];  // all is in range 0 - 255*3
                    data[j++] = scale*all/3;   
                }

                return data;
            }

            //funzione per la creazione del terreno
            function Terreno() {
                var img = new Image();
                img.onload = function () {
                    //get height data from img
                    var data = getHeightData(img,0.1);
                    
                    var geometry = new THREE.BoxGeometry(1,1,1);
                    var material1 = new THREE.MeshBasicMaterial({color: 0xdee334});
                    var material2 = new THREE.MeshBasicMaterial({color: 0x208c0d});
                    var material3 = new THREE.MeshBasicMaterial({color: 0x8c7d62});
                    
                    var x = 0;
                    var terreno = [img.width];					
                    for(i = 0; i < img.width; i++){
                        terreno[i] = [img.height];
                        for(j = 0; j < img.height; j++){
                            if(data[x] <= 10){
                                terreno[i][j] = new THREE.Mesh( geometry, material1);
                            }else if(data[x] > 13){
                                terreno[i][j] = new THREE.Mesh( geometry, material3);
                            }else{
                                terreno[i][j] = new THREE.Mesh( geometry, material2);
                            }
                            
                            //Per avere una posizione in altezza coerente traslo anche su x
                            terreno[i][j].position.set(i, data[x]/4, j);
                                
                            //L'altezza e quindi la scalatura su y viene data dal valore di data[x]
                            terreno[i][j].scale.y = data[x]/2;
                            x++;
                            scene.add(terreno[i][j]);
                        }
                    }
			    }
        
			    // load img source
                img.src = "textures/heightmap2.png";
            }

            //funzione di creazione delle fiamme
            function Flames_creation(dim, flames) {
                var flames_geometry = new THREE.BoxGeometry(2,2,2);
                var flames_materials = new Array();
                flames_materials[0] = new THREE.MeshBasicMaterial({ color:  0xfe0002 });
                flames_materials[1] = new THREE.MeshBasicMaterial({ color:  0xfb7d07 });
                flames_materials[2] = new THREE.MeshBasicMaterial({ color:  0xec6627 });
                flames_materials[3] = new THREE.MeshBasicMaterial({ color:  0xf3dc77 });
                flames_materials[4] = new THREE.MeshBasicMaterial({ color:  0xf5edaa });

                for (var i = 0; i < 200; i++) {
                    flames[i] = new THREE.Mesh(flames_geometry, flames_materials[Math.trunc(Math.random()*(flames_materials.length))]);

                  	var x = Math.random()* dim - dim/2;
                  	var z = Math.random()* dim - dim/2;

                  	while (x*x + z*z > Math.pow((dim/2), 2)) {
                    	  var x = Math.random()* dim - dim/2;
                    	  var z = Math.random()* dim - dim/2;
                  	}
                  	flames[i].position.set(x, 0, z);
                }
            }

            //funzione di animazione delle fiamme
            function Flames_animation(dim, pivot_reference, pivot, flames, height) {
                var d = 0;
                while (d < flames.length) {
                    var h = d;
                    while (h < d+3) {
                        pivot.add(flames[h]);
                        h ++;
                    }
                    for (var i = 0; i < pivot.children.length; i++) {
                        var posx = pivot.children[i].position.x;
                        var posy = pivot.children[i].position.y;
                        var posz = pivot.children[i].position.z;
                        posy -= 0.5;

                        if (posy <= shuttle.position.y - altezza_shuttle/2 + 3*(Math.abs(posx) + Math.abs(posz))) {
                            var x = Math.random()* dim - dim/2;
                            var z = Math.random()* dim - dim/2;

                            while (x*x + z*z > Math.pow((dim/2), 2)) {
                                var x = Math.random()* dim - dim/2;
                                var z = Math.random()* dim - dim/2;
                            }

                            pivot.children[i].position.set(x, shuttle.position.y, z);
                        } else {
                            pivot.children[i].position.y = posy;
                        }
                    }
                    d += 3;
                }
                pivot.position.set((pivot_reference.position.x -(larghezza_tower/3)), - height, pivot_reference.position.z);
                scene.add(pivot);
            }

            //funzione di creazione della colonna di fumo
            function Smoke_creation(dim) {
                var smoke_geometry = new THREE.BoxGeometry(4,8,4);
                var smoke_material = new THREE.MeshBasicMaterial({ color: 0xcccccc, transparency: true, opacity: 0.4 });
                smoke = new Array();
                for (var i = 0; i < 1000; i++) {
                    smoke[i] = new THREE.Mesh(smoke_geometry, smoke_material);

                    var x = Math.random()* dim - dim/2;
                    var z = Math.random()* dim - dim/2;

                    while (x*x + z*z > Math.pow((dim/2), 2)) {
                        var x = Math.random()* dim - dim/2;
                        var z = Math.random()* dim - dim/2;
                    }
                    smoke[i].position.set(x, 0, z);
                }
            }

            //funzione di animazione della colonna di fumo
            function Smoke_animation(dim) {
                var d = 0;
                while (d < smoke.length) {
                    var h = d;
                    while (h < d+3) {
                        smoke_column.add(smoke[h]);
                        h ++;
                    }
                    for (var i = 0; i < smoke_column.children.length; i++) {
                        var posx = smoke_column.children[i].position.x;
                        var posy = smoke_column.children[i].position.y;
                        var posz = smoke_column.children[i].position.z;
                        posy -= 1;
                        var soglia;
                        if (shuttle.position.y <= 250) {
                            soglia = 0;
                        } else {
                            soglia = shuttle.position.y - 250;
                        }
                        if (posy <= soglia) {
                          	var x = Math.random()* dim - dim/2;
                          	var z = Math.random()* dim - dim/2;

                          	while (x*x + z*z > Math.pow((dim/2), 2)) {
                            	var x = Math.random()* dim - dim/2;
                            	var z = Math.random()* dim - dim/2;
                          }
                          	smoke_column.children[i].position.set(x, (shuttle.position.y - altezza_shuttle), z);
                        } else {
                         	smoke_column.children[i].position.y = posy;
                        }
                    }
                    d += 3;
                }
                smoke_column.position.set(shuttle.position.x, 0, shuttle.position.z - spessore_shuttle/2);
                scene.add(smoke_column);
            }

            //funzione di creazione della base di lancio
            function Launch_base() {

	    	    var base_material = new THREE.MeshBasicMaterial({ color: 0x888888, wireframe: false });

	    	    var x = larghezza_base/2 - larghezza_base/14;
	    	    var y = altezza_base/2 + altezza_base/10;
	            var z = spessore_base/2 - spessore_base/14;

	    	    var base_column_geometry = new THREE.BoxGeometry(larghezza_base/7, altezza_base, spessore_base/7);

	    	    var base_column1 = new THREE.Mesh(base_column_geometry, base_material);
	    	    base_column1.position.set(-x, 0, -z);
	    	    launch_base.add(base_column1);

	    	    var base_column2 = new THREE.Mesh(base_column_geometry, base_material);
	    	    base_column2.position.set(x, 0, -z);
	    	    launch_base.add(base_column2);

			    var base_column3 = new THREE.Mesh(base_column_geometry, base_material);
	    	    base_column3.position.set(x, 0, z);
	            launch_base.add(base_column3);

	    	    var base_column4 = new THREE.Mesh(base_column_geometry, base_material);
	    	    base_column4.position.set(-x, 0, z);
	    	    launch_base.add(base_column4);

	    	    var base_plain_geometry = new THREE.BoxGeometry(larghezza_base, altezza_base/5, spessore_base);

	    	    var base_plain = new THREE.Mesh(base_plain_geometry, base_material);
	    	    base_plain.position.set(0, y, 0);
	    	    launch_base.add(base_plain);
            }

            //funzione di creazione della torre
            function Tower() {

                var tower_grey_material = new THREE.MeshBasicMaterial({ color: 0x888888, wireframe: false });
                var tower_dark_grey_material = new THREE.MeshBasicMaterial({ color: 0x333333, wireframe: false });

                //torre
                var tower_base_geometry = new THREE.BoxGeometry(larghezza_tower, altezza_tower/20, spessore_tower);
                var tower_column_geometry = new THREE.BoxGeometry(larghezza_tower/10, altezza_tower/5, spessore_tower/10);
                var tower_base_column_geometry = new THREE.BoxGeometry(larghezza_tower/2, altezza_tower/5, spessore_tower/2);

                var n = 5;
                var i = 0;
                var y = 0;
                var x = larghezza_tower/2 - larghezza_tower/20;
                var z = larghezza_tower/2 - larghezza_tower/20;
                while(i < n){
                    var tower_column1 = new THREE.Mesh(tower_column_geometry, tower_grey_material);
                    tower_column1.position.set(-x, y, -z);
                    tower.add(tower_column1);

                    var tower_column2 = new THREE.Mesh(tower_column_geometry, tower_grey_material);
                    tower_column2.position.set(x, y, -z);
                    tower.add(tower_column2);

                    var tower_column3 = new THREE.Mesh(tower_column_geometry, tower_grey_material);
                    tower_column3.position.set(x, y, z);
                    tower.add(tower_column3);

                    var tower_column4 = new THREE.Mesh(tower_column_geometry, tower_grey_material);
                    tower_column4.position.set(-x, y, z);
                    tower.add(tower_column4);

                    var tower_base_column = new THREE.Mesh(tower_base_column_geometry, tower_grey_material);
                    tower_base_column.position.set(0, y, 0);
                    tower.add(tower_base_column);

                    y += altezza_tower/10 + altezza_tower/40;

                    var tower_base = new THREE.Mesh(tower_base_geometry, tower_dark_grey_material);
                    tower_base.position.set(0, y, 0);
                    tower.add(tower_base);

                    y += altezza_tower/10 + altezza_tower/40;
                    i ++;

                }

                //braccia della torre

                //braccio di mezzo
                y = altezza_tower/5 *2 + altezza_tower/10 *2 + altezza_tower/20 *3;
                x = larghezza_tower;
                z = larghezza_tower/2 - altezza_tower/30;
                var mid_arm_base_geometry = new THREE.BoxGeometry(larghezza_tower, altezza_tower/15, altezza_tower/15);
                var tower_mid_arm_base = new THREE.Mesh(mid_arm_base_geometry, tower_grey_material);
                tower_mid_arm_base.position.set(x, y, z);
                tower.add(tower_mid_arm_base);

                x += larghezza_tower;

                var mid_arm_top_geometry = new THREE.BoxGeometry(larghezza_tower, altezza_tower/20, altezza_tower/20);
                tower_mid_arm_top = new THREE.Mesh(mid_arm_top_geometry, tower_grey_material);
                tower_mid_arm_top.position.set(x, y, z);
                tower.add(tower_mid_arm_top);

                //braccio in cima
                y = altezza_tower/20 *5 + altezza_tower/5 *4 + altezza_tower/10 + altezza_tower/40;
                x = (larghezza_tower * 2 + larghezza_tower/2)/2;
                z = 0;
                var top_arm_geometry = new THREE.BoxGeometry(larghezza_tower * 2 + larghezza_tower/2, altezza_tower/20, altezza_tower/20);
                tower_top_arm1 = new THREE.Mesh(top_arm_geometry, tower_dark_grey_material);
                tower_top_arm1.position.set(x, y, z);
                tower_top_arm.add(tower_top_arm1);

                x = 0;
                y = altezza_tower/20 *5 + altezza_tower/5 *4 + altezza_tower/10 + altezza_tower/40;
                z = 0;
                var alfa = 0;
                n = 90;
                var arm_connections_geometry = new THREE.BoxGeometry(altezza_tower/30, altezza_tower/20, altezza_tower/30);
                while (alfa < n) {
                    var tower_arm_connection = new THREE.Mesh(arm_connections_geometry, tower_grey_material);
                    tower_arm_connection.position.set(x, y, z);
                    tower_arm_connection.rotation.y = Math.PI * alfa / 180;
                    tower_top_arm.add(tower_arm_connection);

                    var shuttle_arm_connection = new THREE.Mesh(arm_connections_geometry, tower_grey_material);
                    shuttle_arm_connection.position.set((larghezza_tower * 2 + larghezza_tower/2), (y - altezza_tower/40), z);
                    shuttle_arm_connection.rotation.y = Math.PI * alfa / 180;
                    tower_top_arm.add(shuttle_arm_connection);

                    alfa += 15;
                }
                tower.add(tower_top_arm);

                //costruzione della punta della torre
                var d = 3;
                i = 0;
                var raggio = altezza_tower/30;
                var altezza = altezza_tower/5;
                y = altezza_tower/20 *5 + altezza_tower/5 *4 + altezza_tower/10 + altezza_tower/20 + altezza_tower/20;
                while (i < d) {
                    var tower_punta_geometry = new THREE.BoxGeometry(raggio, altezza, raggio);
                    alfa = 0;
                    while (alfa < n) {
                        var tower_punta = new THREE.Mesh(tower_punta_geometry, tower_grey_material);
                        tower_punta.position.set(x, y, z);
                        tower_punta.rotation.y = Math.PI * alfa / 180;
                        tower.add(tower_punta);
                        alfa += 15;
                    }
                    raggio -= altezza_tower/60;
                    altezza -= altezza_tower/30;
                    y += altezza;
                    i ++;
                }
            }

            //funzione di creazione dello shuttle comprensivo di ali e propulsori sottostanti
            function Shuttle() {
                var white_material = new THREE.MeshBasicMaterial({ color: 0xfcfcfc, wireframe: false });
                var black_material = new THREE.MeshBasicMaterial({ color: 0x000000, wireframe: false });
                var grey_material = new THREE.MeshBasicMaterial({ color: 0x222222, wireframe: false });

                //costruzione del corpo dello shuttle

                //box centrale dello scheletro dello shuttle
                var base_geometry = new THREE.BoxGeometry(larghezza_shuttle, altezza_shuttle, spessore_shuttle);
                var base_shuttle = new THREE.Mesh(base_geometry, white_material);
                shuttle.add(base_shuttle);

                //blocchi successivi strutturali
                var base_geometry2 = new THREE.BoxGeometry(larghezza_shuttle-10, altezza_shuttle, spessore_shuttle/4);
                var base_shuttle2 = new THREE.Mesh(base_geometry2, white_material);
                base_shuttle2.position.set(0, 0, spessore_shuttle/2 + spessore_shuttle/8);
                shuttle.add(base_shuttle2);

                var base_geometry3 = new THREE.BoxGeometry(larghezza_shuttle-20, altezza_shuttle, spessore_shuttle/4);
                var base_shuttle3 = new THREE.Mesh(base_geometry3, white_material);
                base_shuttle3.position.set(0, 0, spessore_shuttle/2 + spessore_shuttle/4 + spessore_shuttle/8);
                shuttle.add(base_shuttle3);

                //blocco base nero dello shuttle
                var black_base_geometry = new THREE.BoxGeometry(larghezza_shuttle, altezza_shuttle + altezza_shuttle/15, spessore_shuttle/4);
                var black_base_shuttle = new THREE.Mesh(black_base_geometry, black_material);
                black_base_shuttle.position.set(0, altezza_shuttle/30, - spessore_shuttle/8 *5);
                shuttle.add(black_base_shuttle);

                //costruzione della punta dello shuttle

                //blocco centrale della punta
                var base_punta_geometry = new THREE.BoxGeometry(larghezza_shuttle, altezza_shuttle/15, spessore_shuttle/4 * 3);
                var base_punta_shuttle = new THREE.Mesh(base_punta_geometry, white_material);
                base_punta_shuttle.position.set(0, altezza_shuttle/2 + altezza_shuttle/30, -spessore_shuttle/8);
                shuttle.add(base_punta_shuttle);

                //vetro
                var base_vetro_geometry = new THREE.BoxGeometry(larghezza_shuttle-20, altezza_shuttle/15, spessore_shuttle/4);
                var base_vetro = new THREE.Mesh(base_vetro_geometry, black_material);
                base_vetro.position.set(0, altezza_shuttle/2 + altezza_shuttle/30, spessore_shuttle/2 - spessore_shuttle/8);
                shuttle.add(base_vetro);

                var punta_vetro_geometry = new THREE.BoxGeometry(larghezza_shuttle-30, altezza_shuttle/30, spessore_shuttle/4);
                var punta_vetro = new THREE.Mesh(punta_vetro_geometry, black_material);
                punta_vetro.position.set(0, altezza_shuttle/2 + altezza_shuttle/15 + altezza_shuttle/60, spessore_shuttle/8 * 3);
                shuttle.add(punta_vetro);

                //primo blocco dopo il vetro
                var base_punta2_geometry = new THREE.BoxGeometry(larghezza_shuttle-20, altezza_shuttle/30, spessore_shuttle/4);
                var base_punta2 = new THREE.Mesh(base_punta2_geometry, white_material);
                base_punta2.position.set(0, altezza_shuttle/2 + altezza_shuttle/60, spessore_shuttle/2 + spessore_shuttle/8);
                shuttle.add(base_punta2);

                //secondo blocco dopo il vetro
                var base_punta3_geometry = new THREE.BoxGeometry(larghezza_shuttle-30, altezza_shuttle/30, spessore_shuttle/4);
                var base_punta3 = new THREE.Mesh(base_punta3_geometry, white_material);
                base_punta3.position.set(0, altezza_shuttle/2 + altezza_shuttle/60, spessore_shuttle/2 + spessore_shuttle/4 + spessore_shuttle/8);
                shuttle.add(base_punta3);

                //secondo blocco dopo il vetro
                var base_punta4 = new THREE.Mesh(base_punta3_geometry, white_material);
                base_punta4.position.set(0, altezza_shuttle/2 + altezza_shuttle/30 + altezza_shuttle/60, spessore_shuttle/4 + spessore_shuttle/8 * 3);
                shuttle.add(base_punta4);

                //costruzione delle tre strutture dall'esterno verso l'interno per formare la punta
                var n = 3;
                var i = 0;
                var y = altezza_shuttle/2 + altezza_shuttle/15 + altezza_shuttle/60;
                var lato = larghezza_shuttle - (larghezza_shuttle/3 * 2);
                while (i < n){
                    var geometry = new THREE.BoxGeometry(lato, altezza_shuttle/30, spessore_shuttle/4);
                    var block_punta = new THREE.Mesh(geometry, white_material);
                    block_punta.position.set(0, y, spessore_shuttle/8);
                    y += altezza_shuttle/30;
                    lato -= larghezza_shuttle/5;
                    shuttle.add(block_punta);
                    i++;
                }

                i = 0;
                n = 4;
                y = altezza_shuttle/2 + altezza_shuttle/15 + altezza_shuttle/60;
                lato = larghezza_shuttle - (larghezza_shuttle/3);
                while (i < n){
                    var geometry = new THREE.BoxGeometry(lato, altezza_shuttle/30, spessore_shuttle/4);
                    var block_punta = new THREE.Mesh(geometry, white_material);
                    block_punta.position.set(0, y, - spessore_shuttle/8);
                    y += altezza_shuttle/30;
                    lato -= larghezza_shuttle/5;
                    shuttle.add(block_punta);
                    i++;
                }

                i = 0;
                n = 5;
                y = altezza_shuttle/2 + altezza_shuttle/15 + altezza_shuttle/60;
                lato = larghezza_shuttle;
                while (i < n){
                    var geometry = new THREE.BoxGeometry(lato, altezza_shuttle/30, spessore_shuttle/4);
                    var block_punta = new THREE.Mesh(geometry, white_material);
                    var base_block_punta = new THREE.Mesh(geometry, black_material);
                    block_punta.position.set(0, y, - spessore_shuttle/8 *3);
                    base_block_punta.position.set(0, y, - spessore_shuttle/8 *5)
                    y += altezza_shuttle/30;
                    lato -= larghezza_shuttle/5;
                    shuttle.add(block_punta);
                    shuttle.add(base_block_punta);
                    i++;
                }

                //costruzione delle ali

                //ali laterali
                var larghezza_ala = larghezza_shuttle;
                y = altezza_shuttle/20;
                i = altezza_shuttle/2 - (y/2);
                var x = larghezza_shuttle/2 + larghezza_ala/2 + larghezza_ala/5;
                var decr = larghezza_ala/(i/y);
                while (i > 0) {
                    var ala_geometry = new THREE.BoxGeometry(larghezza_ala, y, spessore_shuttle/8);
                    var ala_white_dx = new THREE.Mesh(ala_geometry, white_material);
                    var ala_black_dx = new THREE.Mesh(ala_geometry, black_material);
                    ala_white_dx.position.set( x, -i, - spessore_shuttle/8 *4);
                    ala_black_dx.position.set( x, -i, - spessore_shuttle/8 *5);
                    shuttle.add(ala_white_dx);
                    shuttle.add(ala_black_dx);

                    var ala_white_sx = new THREE.Mesh(ala_geometry, white_material);
                    var ala_black_sx = new THREE.Mesh(ala_geometry, black_material);
                    ala_white_sx.position.set( -x, -i, - spessore_shuttle/8 *4);
                    ala_black_sx.position.set( -x, -i, - spessore_shuttle/8 *5);
                    shuttle.add(ala_white_sx);
                    shuttle.add(ala_black_sx);

                    larghezza_ala -= decr;
                    x -= decr/2;
                    i -= y;
                }

                var geometry_ala1 = new THREE.BoxGeometry(larghezza_shuttle/10, altezza_shuttle/3 *2, spessore_shuttle/8);
                var white_ala1_dx = new THREE.Mesh(geometry_ala1, white_material);
                var black_ala1_dx = new THREE.Mesh(geometry_ala1, black_material);
                var white_ala1_sx = new THREE.Mesh(geometry_ala1, white_material);
                var black_ala1_sx = new THREE.Mesh(geometry_ala1, black_material);
                white_ala1_dx.position.set(x + larghezza_ala/2, -(altezza_shuttle/2 - altezza_shuttle/3), - spessore_shuttle/8 *4);
                black_ala1_dx.position.set(x + larghezza_ala/2, -(altezza_shuttle/2 - altezza_shuttle/3), - spessore_shuttle/8 *5);
                white_ala1_sx.position.set(-(x + larghezza_ala/2), -(altezza_shuttle/2 - altezza_shuttle/3), - spessore_shuttle/8 *4);
                black_ala1_sx.position.set(-(x + larghezza_ala/2), -(altezza_shuttle/2 - altezza_shuttle/3), - spessore_shuttle/8 *5);
                shuttle.add(white_ala1_dx);
                shuttle.add(black_ala1_dx);
                shuttle.add(white_ala1_sx);
                shuttle.add(black_ala1_sx);

                var geometry_ala2 = new THREE.BoxGeometry(larghezza_shuttle/10, altezza_shuttle/4 * 3 + altezza_shuttle/8, spessore_shuttle/8);
                var white_ala2_dx = new THREE.Mesh(geometry_ala2, white_material);
                var black_ala2_dx = new THREE.Mesh(geometry_ala2, black_material);
                var white_ala2_sx = new THREE.Mesh(geometry_ala2, white_material);
                var black_ala2_sx = new THREE.Mesh(geometry_ala2, black_material);
                white_ala2_dx.position.set(x - (larghezza_shuttle/10 - larghezza_ala/2), -(altezza_shuttle/2 - (altezza_shuttle/4 * 3 + altezza_shuttle/8) /2), - spessore_shuttle/8 *4);
                black_ala2_dx.position.set(x - (larghezza_shuttle/10 - larghezza_ala/2), -(altezza_shuttle/2 - (altezza_shuttle/4 * 3 + altezza_shuttle/8) /2), - spessore_shuttle/8 *5);
                white_ala2_sx.position.set(-(x - (larghezza_shuttle/10 - larghezza_ala/2)), -(altezza_shuttle/2 - (altezza_shuttle/4 * 3 + altezza_shuttle/8) /2), - spessore_shuttle/8 *4);
                black_ala2_sx.position.set(-(x - (larghezza_shuttle/10 - larghezza_ala/2)), -(altezza_shuttle/2 - (altezza_shuttle/4 * 3 + altezza_shuttle/8) /2), - spessore_shuttle/8 *5);
                shuttle.add(white_ala2_dx);
                shuttle.add(black_ala2_dx);
                shuttle.add(white_ala2_sx);
                shuttle.add(black_ala2_sx);

                //ala dorsale
                n = 5;
                i = 0;
                larghezza_ala = altezza_shuttle/4;
                lato = altezza_shuttle/20;
                y = altezza_shuttle/5 * 2;
                var z = spessore_shuttle/2 + spessore_shuttle/4 + spessore_shuttle/4 + lato/2;
                while (i < n) {
                    var ala_front_white_geometry = new THREE.BoxGeometry(lato, larghezza_ala, lato);
                    var ala_front_white = new THREE.Mesh(ala_front_white_geometry, white_material);

                    var ala_front_black_geometry = new THREE.BoxGeometry(lato, lato + lato/4, lato);
                    var ala_front_black = new THREE.Mesh(ala_front_black_geometry, black_material);

                    ala_front_white.position.set(0, -y, z);
                    ala_front_black.position.set(0, -((y - larghezza_ala/2) - (lato/2 + lato/8)), z);
                    shuttle.add(ala_front_white);
                    shuttle.add(ala_front_black);
                    larghezza_ala -= lato/2;
                    y += lato;
                    z += lato;
                    i ++;
                }

                //costruzione dei propulsori
                alfa = 0;
                var h = 3;
                n = 90;
                while (alfa < n) {
                    i = 0;
                    larghezza_propulsori_temp = larghezza_shuttle/3;
                    altezza_propulsori_temp = altezza_shuttle/30;
                    spessore_propulsori_temp = larghezza_shuttle/3;
                    y = altezza_shuttle/2 + altezza_propulsori_temp * h - altezza_propulsori_temp/2;
                    while (i < h) {
                        var propulsori_geometry = new THREE.BoxGeometry(larghezza_propulsori_temp, altezza_propulsori_temp, spessore_propulsori_temp);

                        var mesh_propulsori1 = new THREE.Mesh(propulsori_geometry, grey_material);
                        mesh_propulsori1.position.set(0, -y, 0);
                        mesh_propulsori1.rotation.y = Math.PI * alfa / 180;
                        propulsore1.add(mesh_propulsori1);

                        var mesh_propulsori2 = new THREE.Mesh(propulsori_geometry, grey_material);
                        mesh_propulsori2.position.set(0, -y, 0);
                        mesh_propulsori2.rotation.y = Math.PI * alfa / 180;
                        propulsore2.add(mesh_propulsori2);

                        var mesh_propulsori3 = new THREE.Mesh(propulsori_geometry, grey_material);
                        mesh_propulsori3.position.set(0, -y, 0);
                        mesh_propulsori3.rotation.y = Math.PI * alfa / 180;
                        propulsore3.add(mesh_propulsori3);

                        larghezza_propulsori_temp -= larghezza_shuttle/20;
                        spessore_propulsori_temp -= larghezza_shuttle/20;
                        y -= altezza_propulsori_temp;
                        i ++;
                    }
                    alfa += 15;
                }
                propulsore1.position.set(- larghezza_shuttle/3, propulsore1.position.y, - spessore_shuttle/4);
                shuttle.add(propulsore1);
                propulsore2.position.set(+ larghezza_shuttle/3, propulsore1.position.y, - spessore_shuttle/4);
                shuttle.add(propulsore2);
                propulsore3.position.set(propulsore3.position.x, propulsore1.position.y, + larghezza_shuttle/4);
                shuttle.add(propulsore3);
            }

            //funzione di creazione del serbatoio
            function External_tank() {
                var larghezza_tank = larghezza_shuttle;
                var altezza_tank = altezza_shuttle*1.3; //1.5 risulta troppo alto
                var spessore_tank = spessore_shuttle;

                var orange_material = new THREE.MeshBasicMaterial({ color: 0xff8100, wireframe: false });

                var tank_base_geometry = new THREE.BoxGeometry(larghezza_tank, altezza_tank, spessore_tank);

                var n = 180;
                var alfa = 0;
                while (alfa < n) {
                    var external_tank_base = new THREE.Mesh(tank_base_geometry, orange_material);
                    external_tank_base.position.set(0, -altezza_shuttle/3 + 3*altezza_shuttle/5, 0);  //altezza_shuttle/3 alternativa valida per y   y= mesh_propulsori1.position.y + altezza_tank/2
                    external_tank_base.rotation.y = Math.PI * alfa / 180;
                    external_tank.add(external_tank_base);
                    alfa += 15;
                }

                n = 180;
                alfa = 0;
                var h = 6;
                while (alfa < n) {
                    i = 0;
                    larghezza_tank_temp = larghezza_tank;
                    altezza_tank_temp = altezza_tank/10;
                    spessore_tank_temp = spessore_tank;
                    y = external_tank_base.position.y + altezza_tank/2 + altezza_tank_temp/2;
                    while (i < h) {
                        var tank_punta_geometry = new THREE.BoxGeometry(larghezza_tank_temp, altezza_tank_temp, spessore_tank_temp);

                        var external_tank_punta = new THREE.Mesh(tank_punta_geometry, orange_material);
                        external_tank_punta.position.set(0, y, external_tank_base.position.z);
                        external_tank_punta.rotation.y = Math.PI * alfa / 180;
                        external_tank.add(external_tank_punta);
                        larghezza_tank_temp -= larghezza_tank/5;
                        spessore_tank_temp -= spessore_tank/5;
                        altezza_tank_temp -= altezza_tank_temp/5;
                        y += altezza_tank_temp;
                        i ++;
                    }
                    alfa += 15;
                }
                external_tank.position.set(external_tank.position.x, external_tank.position.y, -spessore_shuttle*2);
            }

            //funzione di creazione di un razzo, dx o sx è definito da pos
            function Razzo(razzo, pos) {
                var white_material = new THREE.MeshBasicMaterial({ color: 0xfcfcfc, wireframe: false });

                var larghezza_razzo = larghezza_shuttle/2;
                var altezza_razzo = altezza_shuttle*1.4;
                var spessore_razzo = spessore_shuttle;

                var razzo_base_geometry = new THREE.BoxGeometry(larghezza_razzo, altezza_razzo, spessore_razzo);

                var n = 90;
                var alfa = 0;

                while (alfa < n) {
                    var razzo_base = new THREE.Mesh(razzo_base_geometry, white_material);
                    razzo_base.position.set(0, 0, 0);
                    razzo_base.rotation.y = Math.PI * alfa / 180;
                    razzo.add(razzo_base);

                    alfa += 15;
                }

                alfa = 0;
                var h = 6;
                while (alfa < n) {
                    var i = 0;
                    larghezza_razzo_temp = larghezza_razzo;
                    altezza_razzo_temp = altezza_razzo/20;
                    spessore_razzo_temp = spessore_razzo;
                    y = razzo_base.position.y + altezza_razzo/2 + altezza_razzo_temp/2;
                    while (i < h) {
                        var razzo_punta_geometry = new THREE.BoxGeometry(larghezza_razzo_temp, altezza_razzo_temp, spessore_razzo_temp);

                        var razzo_punta = new THREE.Mesh(razzo_punta_geometry, white_material);
                        razzo_punta.position.set(razzo_base.position.x, y, razzo_base.position.z);
                        razzo_punta.rotation.y = Math.PI * alfa / 180;
                        razzo.add(razzo_punta);

                        larghezza_razzo_temp -= larghezza_razzo/5;
                        spessore_razzo_temp -= spessore_razzo/5;
                        altezza_razzo_temp -= altezza_razzo_temp/5;
                        y += altezza_razzo_temp;
                        i ++;
                    }
                    alfa += 15;
                }

                alfa = 0;
                var h = 3;
                while (alfa < n) {
                    i = 0;
                    var d = 0;
                    larghezza_razzo_temp = larghezza_razzo;
                    spessore_razzo_temp = spessore_razzo;
                    altezza_razzo_temp = altezza_razzo/50;
                    y = razzo_base.position.y - altezza_razzo/2 - altezza_razzo_temp/2 - altezza_razzo_temp*(h - 1)*2;
                    while (d < 2) {
                        while (i < h) {
                            var razzo_propulsori_geometry = new THREE.BoxGeometry(larghezza_razzo_temp, altezza_razzo_temp, spessore_razzo_temp);

                            var razzo_propulsori = new THREE.Mesh(razzo_propulsori_geometry, white_material);
                            razzo_propulsori.position.set(razzo_base.position.x, y, razzo_base.position.z);
                            razzo_propulsori.rotation.y = Math.PI * alfa / 180;
                            razzo.add(razzo_propulsori);

                            larghezza_razzo_temp -= larghezza_razzo/10;
                            spessore_razzo_temp -= spessore_razzo/10;
                            y += altezza_razzo_temp;
                            i ++;
                        }
                        i = 0;
                        y = razzo_base.position.y - altezza_razzo/2 - altezza_razzo_temp/2 - altezza_razzo_temp*(h - 1);
                        larghezza_razzo_temp = larghezza_razzo;
                        spessore_razzo_temp = spessore_razzo;
                        altezza_razzo_temp = altezza_razzo/50;
                        d ++;
                    }
                    alfa += 15;
                }

                if (pos == 0) {
                    razzo.position.set(larghezza_shuttle/2 + larghezza_shuttle/2, razzo.position.y + altezza_shuttle/15, -spessore_shuttle*2);
                } else {
                    razzo.position.set(-(larghezza_shuttle/2 + larghezza_shuttle/2), razzo.position.y + altezza_shuttle/15, -spessore_shuttle*2);
                }
            }

            //funzione di animazione delle braccia della torre
            function Arm_detachment() {
                if (angolo <= 90) {
                    tower_top_arm.rotation.y -= Math.PI * 0.1 / 180;
                    tower_mid_arm_top.position.x -= 0.05;
                }
                angolo += 0.1;
                angolo_return += 0.1;
                time = Date.now();
            }

            //funzione di animazione dello shuttle
            function Launch() {
                var currentTime = Date.now();
                if (currentTime - time < durataAnimazione) {
                    shuttle.position.y += 0.5;
                    flames_propulsore1.visible = true;
                	flames_propulsore2.visible = true;
                	flames_propulsore3.visible = true;
                	flames_razzo_dx.visible = true;
                	flames_razzo_sx.visible = true;
                	smoke_column.visible = true;
                    Flames_animation(larghezza_shuttle/3, propulsore1, flames_propulsore1, flames1, 60);
                    Flames_animation(larghezza_shuttle/3, propulsore2, flames_propulsore2, flames2, 60);
                    Flames_animation(larghezza_shuttle/3, propulsore3, flames_propulsore3, flames3, 60);
                    Flames_animation(larghezza_shuttle/2, razzo_dx, flames_razzo_dx, flames4, 80);
                    Flames_animation(larghezza_shuttle/2, razzo_sx, flames_razzo_sx, flames5, 80);
                    Smoke_animation(larghezza_shuttle*3);

                    controls.autoRotate = true;
                    camera.position.y += 0.5;
                } else {
                	flames_propulsore1.visible = false;
                	flames_propulsore2.visible = false;
                	flames_propulsore3.visible = false;
                	flames_razzo_dx.visible = false;
                	flames_razzo_sx.visible = false;
                	smoke_column.visible = false;
                    Flames_animation(larghezza_shuttle/3, propulsore1, flames_propulsore1, flames1, 60);
                    Flames_animation(larghezza_shuttle/3, propulsore2, flames_propulsore2, flames2, 60);
                    Flames_animation(larghezza_shuttle/3, propulsore3, flames_propulsore3, flames3, 60);
                    Flames_animation(larghezza_shuttle/2, razzo_dx, flames_razzo_dx, flames4, 80);
                    Flames_animation(larghezza_shuttle/2, razzo_sx, flames_razzo_sx, flames5, 80);
                    smoke_column.position.y = 0;


                	controls.autoRotate = false;
                	Reposition();

                }
            }

            //funzione di riposizionamneto dello shuttle
            function Reposition() {
            	if (riposizionato == true) {
            		if (shuttle.position.y >= altezza_shuttle*1.4) {
            			shuttle.position.y = (altezza_shuttle*1.4);
            			if (angolo_return >= 0) {
            				tower_top_arm.rotation.y += Math.PI * 0.1 / 180;
                    		tower_mid_arm_top.position.x += 0.05;
                    		angolo_return -= 0.1;
            			} else {
            				angolo = 0;
            				angolo_return = 0;
            			}
            		} else {
            			shuttle.position.y += (altezza_shuttle*1.4 / 100);
            		}
            	} else {
            		shuttle.position.y = -(altezza_shuttle*1.4);
            		riposizionato = true;
                    camera.position.set(100,200,250);
            	}
            }

            //funzione di gestione globale dell'animazione
            function Animation() {
              	if (angolo <= 90) {
                	Arm_detachment();
              	} else {
                 	Launch();
             	}
            }

            function Update() {
                requestAnimationFrame(Update);
                controls.update();
                stats.update();

                Render();
            }

            function Render() {
                renderer.render(scene, camera);
                Animation();
            }

            Start();
            Update();

            //AUMENTARE LA DIMENSIONE DEI CUBI DEL TERRAIN NELLA GEOMETRY, E POI CREARE UNA SKYSPHERE DI RAGGIO COME IL LATO TOTALE COSì DA PRENDERE TUTTO IL TERRAIN
        </script>
    </body>
</html>
